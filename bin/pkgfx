#!/usr/bin/env bash
#
# pkgfx
#
# This script is the dedicated package manager for BashFX.
# It handles package installation, uninstallation, integrity verification, and linking.
#

# --- Logo Hack ---
#
#  ____ ____ _  _ ____ ____ _  _ 
#  |__| |  | |\/| |___ |__/ |__| 
#  |  | |__| |  | |___ |  \ |  | 
#                                
# -----------------

# Set BASHFX_ROOT to the directory where this script is located.
# This assumes pkgfx is in the bin/ directory relative to BASHFX_ROOT.
export BASHFX_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")"/.. && pwd)"

# Source necessary libraries
source "${BASHFX_ROOT}/pkgs/inc/escape.sh"
source "${BASHFX_ROOT}/pkgs/inc/stderr.sh"
source "${BASHFX_ROOT}/pkgs/inc/include.sh"
source "${BASHFX_ROOT}/pkgs/inc/paths.sh"
source "${BASHFX_ROOT}/pkgs/inc/package.sh"
source "${BASHFX_ROOT}/pkgs/inc/pkglinker.sh"
source "${BASHFX_ROOT}/pkgs/inc/manifest.sh"
source "${BASHFX_ROOT}/pkgs/inc/integrity.sh"

# Global variables for options
opt_debug=0
opt_trace=0
opt_quiet=0
opt_force=0
opt_yes=0
opt_dev=0

# Function to parse command-line options
options() {
    local OPTIND
    while getopts "dtqfyD" opt; do
        case "${opt}" in
            d) opt_debug=1 ;;
            t) opt_trace=1 ;;
            q) opt_quiet=1 ;;
            f) opt_force=1 ;;
            y) opt_yes=1 ;;
            D) opt_dev=1; opt_debug=1; opt_trace=1 ;;
            *) usage; return 1 ;;
        esac
    done
    shift "$((OPTIND-1))"
    return 0
}

# Function to display usage information
usage() {
    cat <<EOF >&2
Usage: pkgfx [options] <command> [args...]

Options:
  -d    Enable debug output
  -t    Enable trace output
  -q    Suppress all output except errors
  -f    Force operation
  -y    Assume yes to all prompts
  -D    Enable developer mode (implies -d and -t)

Commands:
  install <package_name>  Install a package
  uninstall <package_name> Uninstall a package
  verify <package_name>   Verify package integrity
  list                    List installed packages
  help                    Display this help message
EOF
    return 0
}

# Function to inspect available commands (for development/debugging)
inspect() {
    info "Available commands:"
    grep -E '^(do_|fx_)' "${BASH_SOURCE[0]}" | sed 's/^\(do_\|fx_\)//;s/().*$//' | while read -r cmd; do
        info "  ${cmd}"
    
    done
    return 0
}

# Dispatch function to route commands
dispatch() {
    local cmd="$1"
    shift || true

    case "${cmd}" in
        install) do_install "$@" ;;
        uninstall) do_uninstall "$@" ;;
        verify) do_verify "$@" ;;
        list) do_list "$@" ;;
        help) usage ;;
        inspect) inspect ;;
        *) error "Unknown command: ${cmd}"; usage; return 1 ;;
    esac
    return 0
}

# --- Command Implementations ---

do_install() {
    local pkg_id="$1" group pkg_name src_path dst_path

    [ -z "$pkg_id" ] && { error "No package specified for installation."; return 1; }

    # 1. Check if already installed
    is_installed_pkg "$pkg_id"
    [ $? -eq 0 ] && { okay "Package '$pkg_id' is already installed."; return 0; }

    # 2. Validate package and get its source path
    src_path=$(get_pkg_path "$pkg_id")
    [ $? -ne 0 ] && { error "Package '$pkg_id' not found or invalid."; return 1; }
    info "Found package source at: $src_path"

    # 3. Parse group and name
    case "$pkg_id" in
      (*[:.]*) group="${pkg_id%%[:.]*}"; pkg_name="${pkg_id#*[:.]}" ;;
      (*) error "Invalid package format. Use 'group.name'."; return 1 ;;
    esac

    # 4. Define destination and copy files
    local dst_group_path="$FX_LIB/$group"
    dst_path="$dst_group_path/$pkg_name"

    info "Installing '$pkg_id' to '$dst_path'..."
    mkdir -p "$dst_group_path" || { error "Failed to create destination group directory."; return 1; }

    cp -R "$src_path/." "$dst_path/" || { error "Failed to copy package files."; return 1; }
    okay "Package files copied successfully."

    # 5. Link the executable
    _link_pkg_executable "$group" "$pkg_name"
}

_link_pkg_executable() {
    local group="$1" pkg_name="$2"
    local installed_exec="$FX_LIB/$group/$pkg_name/pkg.sh"
    local bin_link="$FX_BIN/$pkg_name"

    if [ ! -f "$installed_exec" ]; then
      note "Package '$pkg_name' has no executable (pkg.sh). Nothing to link."
      return 0
    fi

    # Create symlink in bin/
    info "Linking executable: $bin_link -> $installed_exec"
    ln -s "$installed_exec" "$bin_link" || {
      error "Failed to link $bin_link -> $installed_exec";
      return 1
    }

    okay "Package '$pkg_name' is now available in your PATH."
}

do_uninstall() {
    local pkg_id="$1"
    [ -z "$pkg_id" ] && { error "No package specified for uninstallation."; return 1; }

    info "Uninstalling package: ${pkg_id}"
    # Placeholder for actual uninstallation logic
    # This will involve removing files from FX_LIB and unlinking from FX_BIN
    return 0
}

do_verify() {
    local pkg_id="$1"
    [ -z "$pkg_id" ] && { error "No package specified for verification."; return 1; }

    info "Verifying package: ${pkg_id}"
    # Placeholder for actual verification logic
    # For now, always return success to allow testing of install/uninstall flow
    return 0
}

do_list() {
    local this="$1"
    local pkg_root="$FXI_PKG_DIR"
    local pkg_path pkg

    case "$this" in
      (*[:.]*) group="${this%%[:.]*}"; pkg="${this#*[:.]}" ;;
      (*) group="$this";;
    esac

    if [[ -z "$pkg_root" || ! -d "$pkg_root" ]]; then
      error "[PKG] Invalid or unset FX_INIT_PKGS: $pkg_root"
      return 1
    fi

    if [ -n "$group" ]; then
      # List packages within a specific group
      if [ ! -d "$pkg_root/$group" ]; then
        error "[PKG] Group '$group' not found under $pkg_root"
        return 1
      fi

      if [ -n "$pkg" ]; then

        if [ ! -d "$pkg_root/$group/$pkg" ]; then
          error "[PKG] Package '$pkg' not found under $group"
          return 1
        else
          echo "$group.$pkg";
        fi

      else

        # Use the helper function to avoid code duplication
        _list_packages_in_group "$group" "$pkg_root/$group"

      fi
    else
      # List all group.pkg pairs
      for group_path in "$pkg_root"/*; do
        [ -d "$group_path" ] || continue
        group=$(basename "$group_path")

        # Use the helper function to avoid code duplication
        _list_packages_in_group "$group" "$group_path"

      done
    fi
}

# Helper function: Lists packages within a given group directory
# This generalizes the common logic for iterating and printing group.pkg.
# Arguments:
#   $1: group_name (e.g., "core", "util")
#   $2: group_dir (absolute path to the group's directory)
_list_packages_in_group() {
    local group_name="$1"
    local group_dir="$2"
    local pkg_path pkg

    for pkg_path in "$group_dir"/*; do
      [ -d "$pkg_path" ] || continue # Skip non-directories
      pkg=$(basename "$pkg_path")
      echo "$group_name.$pkg"
    done
}

# Main entry point
main() {
    options "$@" || return 1
    local args=("$@")
    if [[ "${#args[@]}" -eq 0 ]]; then
        usage
        return 1
    fi
    dispatch "${args[@]}"
    return 0
}

# Execute main
main "$@"