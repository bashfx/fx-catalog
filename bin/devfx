#!/usr/bin/env bash
#===============================================================================
# 
#  ________  ________  ________  ___  ___  ________ ___    ___ 
# |\   __  \|\   __  \|\   ____\|\  \|\  \|\  _____\\  \  /  /|
# \ \  \|\ /\ \  \|\  \ \  \___|\ \  \\\  \ \  \__/\ \  \/  / /
#  \ \   __  \ \   __  \ \_____  \ \   __  \ \   __\\ \    / / 
#   \ \  \|\  \ \  \ \  \|____|\  \ \  \ \  \ \  \_| /     \/  
#    \ \_______\ \__\ \__\____\_\  \ \__\ \__\ \__\ /  /\   \  
#     \|_______|\|__|\|__|\_________\|__|\|__|\|__|/__/ /\ __\ 
#                        \|_________|              |__|/ \|__| 
#                                    
#===============================================================================
#-------------------------------------------------------------------------------
#$ name: devfx (becomes fx in runtime)
#$ author: qodeninja & Shebang
#$ semver: 0.2.0
#-------------------------------------------------------------------------------
#=====================================code!=====================================


  
  SELF_PATH="$0";


  if [ -n "$FX_INC_DIR" ]; then
    ___="$FX_INC_DIR"; #fx
  else
    if [ -z "$FXI_INC_DIR" ]; then
      #missing !
      printf "BashFX Setup incomplete, missing include directory!";
      exit 1;
    else
      ___="$FXI_INC_DIR/include.sh"; #init
    fi
  fi
  source "$___";
  unset ___;


  fx_var_list=(FX_BIN FX_LIB FX_ETC FX_DATA FX_STATE FX_RC FX_APP_NAME);

  # @lbl this context


  this_context_fx(){
    think "Setting this context [fx]";
    THIS_NAME="fx";
    THIS_RC_NAME="fx.rc";
    THIS_RC_VAR="FX_RC";
    THIS_SELF="$SELF_PATH";
    THIS_LABEL="bashfx";
    THIS_LINK_BLOCK="link:${THIS_LABEL}";
    THIS_RC_BLOCK="rc:${THIS_LABEL}";
  }

  fx_this_check(){
    trace "this_name : $THIS_NAME";
    trace "this_rc_name  : $THIS_RC_NAME";
    trace "this_rc_var   : $THIS_RC_VAR";
    trace "this_self     : $THIS_SELF";
    trace "this_label    : $THIS_LABEL";
    trace "this_link_block: $THIS_LINK_BLOCK";
    trace "this_rc_block : $THIS_RC_BLOCK";
    return 0;
  }

  this_context_fx;
  

#-------------------------------------------------------------------------------
# Core Includes
#-------------------------------------------------------------------------------


 # Use smart_source to load libraries
  fx_smart_source paths    || exit 1
  fx_smart_source proflink || exit 1
  fx_smart_source rcfile   || exit 1
  fx_smart_source template || exit 1
  fx_smart_source manifest   || exit 1
  fx_smart_source integrity  || exit 1
  fx_smart_source pkglinker  || exit 1


#-------------------------------------------------------------------------------
# Templates
#-------------------------------------------------------------------------------


  _get_help_text(){
    # Using a here-document is more robust than parsing from comments.
    # It aligns with Pillar III (Modularity) and V (Clarity).
    # The color variables (${b}, ${x}, etc.) are expanded because we use `EOF`
    # instead of `'EOF'`.
    cat <<EOF

  ${b}DEVFX [command] [--flags|-f] ${x}

  ${w2}[ Commands ]${x}

  ${o}setup${x}  - auto run through install steps
  ${o}deploy${x} - copy packages to lib
  ${o}link${x}   - deploy package to .local/bin
  ${o}unlink${x} - deploy package to .local/bin 
  ${o}chk${x}    - check if a package is installed
  ${o}pkgs${x}   - list available packages

  ${w2}[ Dev ]${x}

  ${o}insp  ${x} - debug available functions
  ${o}dem   ${x} - debug embedded docs
  ${o}dlink ${x} - debug profile link output
  ${o}vars  ${x} - dump vars with prefix FX_*

  ${w2}[ Flags ]${x}

  ${o}${ff} [-d] debug${x}, ${o}${ff} [-t] trace${x}, ${o}${ff} [-V] verbose${x}, ${o}${ff} [-q] quiet${x}, ${o}${ff} [-f] flags${x}, ${o}${ff} [-D] dev${x}
EOF
  }

  usage(){
    # Calling a local function is more self-contained and robust
    # than relying on an external parser tool like 'docx'.
    _get_help_text
  }

  _get_rc_template(){
    # This here-document replaces the fragile 'rc:bashfx' comment block.
    # It is now used by fx_install_system to create the rc file.
    cat <<EOF
#!/usr/bin/env bash

# Updated: $(date)

export FX_INSTALLED=0;
export FX_APP_NAME="$FX_APP_NAME";
export FX_PROFILE="$FX_PROFILE";
export FX_BIN="$FX_BIN";
export FX_LIB="$FX_LIB";
export FX_INC="$FX_INC";
export FX_ETC="$FX_ETC";
export FX_DATA="$FX_DATA";
export FX_STATE="$FX_STATE";
export FX_RC="$FX_ETC/fx.rc";
EOF
  }

  _get_link_template(){
    # This here-document replaces the fragile 'link:bashfx' comment block.
    # It is now used by fx_install_system to link the rc file to the user's profile.
    cat <<EOF
#### bashfx ####
  
 # Updated: $(date)
 # bashfx installed - do not manually edit this block
 # use [fx unlink] to remove
 export FX_RC="$FX_RC";

 if [ -f "\${FX_RC}" ]; then
   source "\${FX_RC}" --load-vars;
 else
   echo "${o}[FX] fx.rc file is missing. Run devfx repair! ${x}";
 fi

########
EOF
  }


#-------------------------------------------------------------------------------
# 
#-------------------------------------------------------------------------------

# @lbl options

  options(){
    # Using local ensures these variables don't leak into the global scope.
    local err
    opt_debug=1; opt_quiet=1; opt_trace=1; opt_silly=1;
    opt_yes=1; opt_dev=1; opt_flags=1;

    # Process arguments in a single loop for clarity and efficiency.
    for arg in "$@"; do
      case "$arg" in
        --yes|-y)           opt_yes=0;;
        --flag*|-f)         opt_flags=0;;
        --debug|-d)         opt_debug=0;;
        --tra*|-t)          opt_trace=0;;
        --sil*|--verb*|-V)  opt_silly=0;;
        --dev|-D)           opt_dev=0;;
        --quiet|-q)         opt_quiet=0;;
        -*)                 err="Invalid flag [$arg].";; # Capture unknown flags
      esac
    done

    # Apply hierarchical verbosity rules.
    # Higher levels of verbosity enable lower levels.
    [ "$opt_silly" -eq 0 ] && { opt_trace=0; opt_debug=0; }
    [ "$opt_trace" -eq 0 ] && { opt_debug=0; }
    [ "$opt_dev" -eq 0 ]   && { opt_debug=0; opt_flags=0; }

    # Final override: if quiet is on, it trumps all other verbosity.
    if [ "$opt_quiet" -eq 0 ]; then
      opt_debug=1; opt_trace=1; opt_silly=1;
    else
      warn "Quiet is $opt_quiet";
    fi

    [ -n "$err" ] && fatal "$err";
  }

#-------------------------------------------------------------------------------
# Embedded Docx
#-------------------------------------------------------------------------------

  is_empty_file(){
    local this=$1;
    trace "Checking for empty file ($this)";
    if [[ -s "$this" ]]; then
      if grep -q '[^[:space:]]' "$this"; then
        return 1;
      else
        return 0;
      fi
    fi
    return 0;
  }

  has_subdirs(){
    local dir="$1"
    for d in "$dir"/*; do
      [ -d "$d" ] && return 0
    done
    return 1
  }


  function_exists(){
    [ -n "$1" ] && declare -F "$1" >/dev/null
  }

#-------------------------------------------------------------------------------
# INIT
#-------------------------------------------------------------------------------



  init_fx(){
    local app;
    if [ -z "$FX_RC" ]; then 
      info "[VAR] FX vars loading from init ...";
      export FX_APP_NAME='fx';
      app="$FX_APP_NAME";
      export FX_BIN="${FX_BIN:-$XDG_FX_BIN/$app}";
      export FX_LIB="${FX_LIB:-$XDG_FX_LIB/$app}";
      export FX_INC="${FX_INC:-$FX_LIB/inc}";
      export FX_ETC="${FX_ETC:-$XDG_FX_CONFIG/$app/etc}";
      export FX_DATA="${FX_DATA:-$XDG_FX_SHARE/$app}";
      export FX_STATE="${FX_STATE:-$XDG_FX_STATE/$app}";
      export FX_RC="${FX_RC:-${FX_ETC}/fx.rc}";

      export FX_PROFILE=${FX_PROFILE:-$(canonical_profile)}; #allow a prev set
    fi
  }


  ensure_fx_setup() {
    trace "[DIR] checking application directories...";
    local this var val;

    for var in "${fx_var_list[@]}"; do

      this=$(deref_var "$var") #bash 3.2
       
      # Skip empty values
      [ -z "${this}" ] && {
        error "$var is unset or empty!" >&2;
        return 1;
      }

      # Check if it's a directory, or try to create it
      #'^FX_INIT_|^FX_RC|^FX_APP'
      case "$var" in
        (FX_RC|FX_APP_NAME) continue ;;  # skip these vars
      esac

      
      if [ -d "$this" ]; then
        trace "[DIR] $var → $this exists"
      else
        trace "[DIR] $var → $this does not exist, attempting to create..."
        mkdir -p "$this" || {
          err="Failed to create $this for $var" >&2
          return 1;
        }
        okay "Created $this for $var"
      fi
    done #end for
    return 0;
  }



  do_init(){
    init_fx;
  }


#-------------------------------------------------------------------------------
# FX API
#-------------------------------------------------------------------------------


  fx_get_rc_file(){
    local rc;
    think "Getting this fx rc file...";
    this_context_fx;
    rc="${FX_ETC}/fx.rc"; # Directly use the intended path
    echo "$rc";
    return 0;
  }


  fx_has_link(){
    local rc ret=1;
    fx_link_cmd "has"; ret=$?; ret=$?;
    [ $ret -eq 0 ] && okay "FX rc file found." || warn "FX link not found.";
    return $ret;
  }


  fx_del_link(){
    local rc ret=1;
    fx_link_cmd "del"; ret=$?;
    [ $ret -eq 0 ] && info "FX rc link removed" || warn "FX rc already unlinked";
    return $ret;
  }


  fx_set_link(){
    local rc ret=1;
    fx_link_cmd "add"; ret=$?;
    [ $ret -eq 0 ] && info "FX link added to profile" || warn "Fx could not link to profile";
    return $ret;
  }

  fx_link_cmd(){
    local func call="$1" rc=${FX_RC:-=$(fx_get_rc_file)} ret=1;
    case $call in
      (has) cmd='has_profile_link' ;;
      (add) cmd='set_profile_link' ;;
      (del) cmd='rem_profile_bak' ;;
      (*)
        return 1;
      ;;
    esac
    if [ -n "$cmd" ] && function_exists "$cmd"; then
      "$cmd" "$rc";  
      ret=$?;
    fi
    return $ret;
  }


  fx_print_embed(){
    # This function can now call the standard template function directly
    _get_rc_template
  }


#-------------------------------------------------------------------------------
# Troubleshooting
#-------------------------------------------------------------------------------

  do_vars(){
    trace "Dumping debug vars";
    local call="$1" arg="$2" cmd= ret;
    case $call in
      (xdg)    env | grep '^XDG_FX_';;
      (fx)     env | grep '^FX_' | grep -v '^FX_INIT_' ;;
      (init)   env | grep '^FX_INIT';;
      (*)
        if [ ! -z "$call" ]; then
          err="Invalid prefix => $call";
          return 1;
        fi
      ;;
    esac
    return 0;
  }

  #TODO:refactor for robustness
  do_inspect(){
    local i
    xline
    info "Available 'do_' functions:"
    declare -F | grep 'do_' | awk '{print $3}'
    xline
    info "Available dispatch commands:"
    for i in "${!_dispatch_cmds[@]}"; do
      info "  ${_dispatch_cmds[i]} -> ${_dispatch_funcs[i]}"
    done
  }

  fx_dev_rcfile(){
    this_context_fx;
    dump_this_rc_file;
  }

# @lbl fx clean

  fx_dev_cleanup(){
    think "Doing Dev cleanup...";
    local rcfile=$(fx_get_rc_file); ret=$?;
    del_this_rc_file; ret=$?;
    fx_del_link;
    # optional remove fxi aliases
  }

  # @lbl fx clean
  # Cleans up all installed packages and manifest
  fx_dev_clean_packages() {
    require_dev || { error "This function requires dev mode."; return 1; }
    think "Cleaning up all installed packages and manifest..."
    if [ -d "$FX_LIB" ]; then
      rm -rf "$FX_LIB" || { error "Failed to remove $FX_LIB"; return 1; }
      okay "Removed $FX_LIB"
    else
      warn "$FX_LIB does not exist, skipping removal."
    fi

    if [ -f "$FX_ETC/manifest.log" ]; then
      rm -f "$FX_ETC/manifest.log" || { error "Failed to remove manifest.log"; return 1; }
      okay "Removed $FX_ETC/manifest.log"
    else
      warn "Manifest file does not exist, skipping removal."
    fi
    okay "Package cleanup complete."
    return 0
  }


# @lbl fx api

  fx_self_promote(){
    info "Promoting devfx to fx..."
    local fx_bin_path="$FX_BIN/fx"
    cp "$SELF_PATH" "$fx_bin_path" || { error "Failed to copy devfx to $fx_bin_path"; return 1; }
    chmod +x "$fx_bin_path" || { error "Failed to make $fx_bin_path executable"; return 1; }
    okay "devfx successfully promoted to fx at $fx_bin_path"
    return 0
  }


#-------------------------------------------------------------------------------
# Setup
#-------------------------------------------------------------------------------
  
# @lbl setup

  setup(){
    local rc res ret=1;
    think "Setup starting....."

    this_context_fx;
    init_fx;
    fx_this_check;

    if ensure_fx_setup; then
      okay "System has valid paths.";
      fx_install_system;
    else
      error "System paths are invalid.";
    fi
  }

  do_setup(){
    trace "Setting up FX..."
    setup;
  }

  fx_install_system(){
    info "Installing BashFX system..."
    
    # Step 1: Deploy all packages and create the manifest using pkgfx
    # This step will be handled by pkgfx's install command, which will iterate through packages
    # and add them to the manifest, then link them.
    # For now, we'll assume pkgfx handles the deployment of all core packages.
    # A future task will define how pkgfx discovers and installs these.
    # For the current setup, we'll simulate this by calling pkgfx install on known core packages.
    
    # Example: Install a dummy package to demonstrate pkgfx integration
    # This will be replaced by a proper package discovery and installation mechanism
    # "$FX_BIN/pkgfx" install "/path/to/some/core/package.sh" || { error "Core package installation failed."; return 1; }

    # Step 2: Verify the integrity of all deployed packages using pkgfx
    if [ -x "$FX_BIN/pkgfx" ]; then
      "$FX_BIN/pkgfx" verify || { error "Package integrity verification failed."; return 1; }
    else
      warn "pkgfx not found or not executable, skipping package verification."
    fi
    
    # Step 3: Create and link the rc file
    local rc_file profile_file link_content
    rc_file=$(fx_get_rc_file)
    profile_file=${FX_PROFILE:-$(canonical_profile)}

    # Create the rc file using a robust here-doc template.
    _get_rc_template > "$rc_file" || { error "Failed to save rc file."; return 1; }
    okay "Created rc file at $rc_file"

    # Add the source link to the user's profile if it doesn't exist.
    link_content=$(_get_link_template)
    if ! grep -qF -- "$link_content" "$profile_file"; then
      info "Adding BashFX source to profile: $profile_file"
      echo -e "\n$link_content" >> "$profile_file"
    fi
    
    # Step 4: Promote devfx to fx
    fx_self_promote || { error "Failed to promote devfx to fx."; return 1; }
    
    # Step 5: Clean up the temporary setup environment
    info "Cleaning up temporary setup environment..."
    # Corrected path from 'setup.dev' to 'launch.dev'
    "$FXI_ROOT_DIR/launch.dev" reset || warn "Failed to clean up temporary setup environment."
    
    okay "BashFX installation complete! Please reload your shell (e.g., 'source ~/.bashrc' or open a new terminal) to activate the 'fx' command."
  }




#-------------------------------------------------------------------------------
# Feature Drivers
#-------------------------------------------------------------------------------

  fx_dispatch_driver() {
    local feature_num="$1"
    shift # Remove the feature number from the arguments list
    local driver_func="fx_f$(printf "%03d" "$feature_num")_driver"

    # Source the specific test driver file if it exists
    local test_driver_file="$(dirname "${BASH_SOURCE[0]}")/../tests/test-pkgfx.sh" # Specific for FEATURE-007
    if [ -f "$test_driver_file" ]; then
      source "$test_driver_file"
    fi

    if function_exists "$driver_func"; then
      info "Executing driver for FEATURE-$feature_num..."
      "$driver_func" "$@" # Pass remaining arguments to the driver
    else
      error "Driver function '$driver_func' not found for FEATURE-$feature_num."
      return 1
    fi
  }

  # @driver F003
  fx_f003_driver() {
    local ret=0
    info "DRIVER: Testing FEATURE-003 (Safe Package Deployment)"
    
    # This is a simple "happy path" test.
    # It relies on the setup having been run correctly.
    think "Verifying that the manifest file exists and is not empty..."
    [ -s "$FX_ETC/manifest.log" ] || { error "Manifest file is missing or empty."; return 1; }
    okay "Manifest file exists."

    think "Verifying a known package (semver) is in the manifest..."
    grep -q "semver" "$FX_ETC/manifest.log" || { error "semver package not found in manifest."; ret=1; }
    
    if [ $ret -eq 0 ]; then
      okay "semver package found in manifest."
      okay "DRIVER F003: PASSED"
    else
      error "DRIVER F003: FAILED"
    fi
    return $ret
  }

  # @driver F004
  fx_f004_driver() {
    info "DRIVER: Testing FEATURE-004 (Package Integrity & Linking)"
    
    think "Running master integrity check..."
    # The function returns 0 on success
    fx_integrity_verify_all
    local ret=$?

    if [ $ret -eq 0 ]; then
      okay "DRIVER F004: PASSED"
    else
      error "DRIVER F004: FAILED"
    fi
    return $ret
  }

  _initialize_environment() {
    # Attempt to load the RC file first to get existing settings.
    if load_this_rc_file; then
      info "[RC] FX values loaded from fx.rc";
    fi

    # If core XDG variables are missing, initialize them.
    if [[ -z "$XDG_FX_HOME" || -z "$XDG_FX_LOCAL" ]]; then
      trace "XDG environment not found, initializing..."
      init_xdg;
    fi

    # If the core FX_RC variable is still not set, it means this is likely
    # a first run or a broken environment, so we initialize the defaults.
    if [ -z "$FX_RC" ]; then
      trace "FX environment not found, initializing defaults..."
      init_fx;
    fi
  }



#-------------------------------------------------------------------------------
# System Funcs
#-------------------------------------------------------------------------------
  
  stat_check(){
    local str prof;
    prof=${FX_PROFILE:-$(standard_profile)};
    
    str+="\t--> Input: ${white2}$1 $2 $3 $4 $5 $6 ${x}\n\n";
    str+="\t FX_RC: $FX_RC \n\n";
    str+="\t FX_PROFILE: $prof \n\n";
    str+="\t$(__flag $opt_flags "stats [-f]")\n";
    str+="\t$(__flag $opt_debug "debug [-d]")  \t$(__flag $opt_trace "trace [-t]")\n";
    str+="\t$(__flag $opt_quiet "quiet [-q]")  \t$(__flag $opt_yes   "yes   [-y]")\n";
    str+="\t$(__flag $opt_silly "silly [-V]")  \t$(__flag $opt_dev   "dev   [-D]")\n";  
    quiet_off;
    __boltbox "$str";
  }

# @lbl dispatch

  # Define command mappings for the 'do_inspect' function.
  # This decouples inspection from the dispatch implementation.
  _dispatch_cmds=( "prof" "docs" "has_link" "link" "unlink" "rc" "init" "vars" "insp" "!" "clean" "clean-pkgs" "stat" "setup" "driver" "help" "?" "noop" )
  _dispatch_funcs=( "dev_dump_profile" "fx_print_embed" "fx_has_link" "fx_set_link" "fx_del_link" "fx_dev_rcfile" "do_init" "do_vars" "do_inspect" "do_inspect" "fx_dev_cleanup" "fx_dev_clean_packages" "stat_check" "do_setup" "fx_dispatch_driver" "usage" "usage" "noop" )

  dispatch(){
    local call="$1" arg="$2" exc cmd= ret;

    case $call in
      (prof)        cmd='dev_dump_profile';; # Note: dev_dump_profile is not defined in this script
      (docs)        cmd='fx_print_embed';;
      (has_link)    cmd='fx_has_link';;
      (link)        cmd='fx_set_link';;
      (unlink)      cmd='fx_del_link';;
      (rc*)         cmd='fx_dev_rcfile';;
      (init)        cmd='do_init';;
      (vars)        cmd='do_vars';;
      (insp*|!)     cmd='do_inspect';;
      (clean)       cmd='fx_dev_cleanup';;
      (clean-pkgs)  cmd='fx_dev_clean_packages';;
      (stat)        cmd='stat_check';;
      (setup)       cmd='do_setup';;
      (driver)      cmd='fx_dispatch_driver';;
      (help|?)      cmd="usage";;
      (noop)        cmd="noop";;
    esac

    if [ -n "$cmd" ] && function_exists "$cmd"; then
      shift # remove the command so we can pass the rest
      "$cmd" "$@";   # Pass all extra arguments if cmd is defined
      ret=$?;
    else
      __errbox "Dispatch error, could not find function ($cmd) for command ($call)";
    fi
    [ -n "$err" ] && fatal "$err";
    echo -ne "\n\n";

    return $ret;
  }


  main(){
    local str ret=1
    think "loading main"
    __logo "$SELF_PATH" 3 12;
    require_dev && str="\t${red2}${boto} Dev mode enabled ${boto}${x}" || str="\n\t\t${grey}${bowtie} User Mode ${x}"
    stderr "$str\n";

    _initialize_environment

    dispatch "$@"; ret=$?

    [ -n "$err" ] && fatal "$err"
    return $ret
  }

  #command for testing options and setup
  noop(){ return 0; }



#-------------------------------------------------------------------------------


  if [ "$0" = "-bash" ]; then
    :
  else

    orig_args=("${@}")
    options "${orig_args[@]}";

    # If --flags was passed, show stats and exit. This is a meta-command.
    [ $opt_flags -eq 0 ] && { stat_check "${orig_args[@]}"; exit 0; }

    # Filter out flags to get positional arguments for main().
    args=()
    for arg in "${orig_args[@]}"; do
      [[ "$arg" == -* ]] && continue
      args+=("$arg")
    done

    main "${args[@]}";

  fi
