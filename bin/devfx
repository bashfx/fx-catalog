#!/usr/bin/env bash
#===============================================================================
# 
#  ________  ________  ________  ___  ___  ________ ___    ___ 
# |\   __  \|\   __  \|\   ____\|\  \|\  \|\  _____\\  \  /  /|
# \ \  \|\ /\ \  \|\  \ \  \___|\ \  \\\  \ \  \__/\ \  \/  / /
#  \ \   __  \ \   __  \ \_____  \ \   __  \ \   __\\ \    / / 
#   \ \  \|\  \ \  \ \  \|____|\  \ \  \ \  \ \  \_| /     \/  
#    \ \_______\ \__\ \__\____\_\  \ \__\ \__\ \__\ /  /\   \  
#     \|_______|\|__|\|__|\_________\|__|\|__|\|__|/__/ /\ __\ 
#                        \|_________|              |__|/ \|__| 
#                                    
#===============================================================================
#-------------------------------------------------------------------------------
#$ name: devfx (becomes fx in runtime)
#$ author: Qodeninja
#$ semver: 0.4.0 
#-------------------------------------------------------------------------------
#=====================================code!=====================================

  # @ top
  
  SELF_PATH="$0";

  _is_dir(){
    [ -n "$1" ] && [ -d "$1" ] && return 0;
    return 1;
  }


#-------------------------------------------------------------------------------
# Core Includes
#-------------------------------------------------------------------------------


  if _is_dir "$FX_INC_DIR"; then
    _inc="$FX_INC_DIR";
    _app="$FX_APP_DIR";
  elif _is_dir "$FXI_INC_DIR"; then
    _inc="$FXI_INC_DIR";
    _app="$FXI_APP_DIR";
  else 
    printf "[ENV]. Cant locate [include] ($_inc). Fatal.\n";
    exit 1;
  fi

#-------------------------------------------------------------------------------
# Core Includes
#-------------------------------------------------------------------------------

  source "$_inc/include.sh"; 

  if _is_dir "$_app/knife"; then
    _knife="$_app/knife/knife.sh";
  else 
    printf "[ENV] Cant locate [kinfe]. Fatal.\n";
    exit 1;
  fi

  $_knife;

#-------------------------------------------------------------------------------
# Core Includes
#-------------------------------------------------------------------------------


  fx_var_list=(FX_BIN FX_LIB FX_ETC FX_DATA FX_STATE FX_RC FX_APP_NAME);

  this_context_fx(){
    think "Setting this context [fx]";
    THIS_NAME="fx";
    THIS_RC_NAME="fx.rc";
    THIS_RC_VAR="FX_RC";
    THIS_SELF="$SELF_PATH";
    THIS_LABEL="bashfx";
    THIS_LINK_BLOCK="link:${THIS_LABEL}";
    THIS_RC_BLOCK="rc:${THIS_LABEL}";
  }

  fx_this_check(){
    trace "this_name : $THIS_NAME";
    trace "this_rc_name  : $THIS_RC_NAME";
    trace "this_rc_var   : $THIS_RC_VAR";
    trace "this_self     : $THIS_SELF";
    trace "this_label    : $THIS_LABEL";
    trace "this_link_block: $THIS_LINK_BLOCK";
    trace "this_rc_block : $THIS_RC_BLOCK";
    return 0;
  }

  this_context_fx;
  

#-------------------------------------------------------------------------------
# Core Includes
#-------------------------------------------------------------------------------


 # Use smart_source to load libraries
  fx_smart_source paths    || exit 1
  fx_smart_source proflink || exit 1
  fx_smart_source rcfile   || exit 1
  fx_smart_source template || exit 1
  fx_smart_source manifest   || exit 1
  fx_smart_source integrity  || exit 1
  fx_smart_source pkglinker  || exit 1


#-------------------------------------------------------------------------------
# Templates
#-------------------------------------------------------------------------------


  _get_help_text(){
    # Using a here-document is more robust than parsing from comments.
    # It aligns with Pillar III (Modularity) and V (Clarity).
    # The color variables (${b}, ${x}, etc.) are expanded because we use `EOF`
    # instead of `'EOF'`.
    cat <<EOF

  ${b}DEVFX [command] [--flags|-f] ${x}

  ${w2}[ Commands ]${x}

  ${o}setup${x}  - auto run through install steps
  ${o}deploy${x} - copy packages to lib
  ${o}link${x}   - deploy package to .local/bin
  ${o}unlink${x} - deploy package to .local/bin 
  ${o}chk${x}    - check if a package is installed
  ${o}pkgs${x}   - list available packages

  ${w2}[ Dev ]${x}

  ${o}insp  ${x} - debug available functions
  ${o}dem   ${x} - debug embedded docs
  ${o}dlink ${x} - debug profile link output
  ${o}vars  ${x} - dump vars with prefix FX_*

  ${w2}[ Flags ]${x}

  ${o}${ff} [-d] debug${x}, ${o}${ff} [-t] trace${x}, ${o}${ff} [-V] verbose${x}, ${o}${ff} [-q] quiet${x}, ${o}${ff} [-f] flags${x}, ${o}${ff} [-D] dev${x}
EOF
  }

  usage(){
    # Calling a local function is more self-contained and robust
    # than relying on an external parser tool like 'docx'.
    _get_help_text
  }

  _get_rc_template(){
    # This here-document replaces the fragile 'rc:bashfx' comment block.
    # It is now used by fx_install_system to create the rc file.
    cat <<EOF
#!/usr/bin/env bash

# Updated: $(date)

export FX_INSTALLED=0;
export FX_APP_NAME="$FX_APP_NAME";
export FX_PROFILE="$FX_PROFILE"; 
export FX_BIN_DIR="$FX_BIN";
export FX_LIB_DIR="$FX_LIB";
export FX_INC_DIR="$FX_INC";
export FX_APP_DIR="$FX_APP";
export FX_ETC_DIR="$FX_ETC";
export FX_DATA_DIR="$FX_DATA";
export FX_STATE_DIR="$FX_STATE";
export FX_RC="$FX_ETC/fx.rc";
EOF
  }

  _get_link_template(){
    # This here-document replaces the fragile 'link:bashfx' comment block.
    # It is now used by fx_install_system to link the rc file to the user's profile.
    cat <<EOF
#### bashfx ####
  
 # Updated: $(date)
 # bashfx installed - do not manually edit this block
 # use [fx unlink] to remove
 export FX_RC="$FX_RC";

 if [ -f "\${FX_RC}" ]; then
   source "\${FX_RC}" --load-vars;
 else
   echo "${o}[FX] fx.rc file is missing. Run devfx repair! ${x}";
 fi

########
EOF
  }


#-------------------------------------------------------------------------------
# 
#-------------------------------------------------------------------------------

# @info : options() moved to stdopts.sh as a general library function


#-------------------------------------------------------------------------------
# INIT
#-------------------------------------------------------------------------------


  init_fx(){
    local app;
    if [ -z "$FX_RC" ]; then 
      info "[VAR] FX vars loading from init ...";
      export FX_APP_NAME='fx';
      app="$FX_APP_NAME";



      export FX_BIN="${FX_BIN:-$XDG_FX_BIN/$app}";

      export FX_ETC="${FX_ETC:-$XDG_FX_CONFIG/$app/etc}";
      export FX_DATA="${FX_DATA:-$XDG_FX_SHARE/$app}";
      export FX_STATE="${FX_STATE:-$XDG_FX_STATE/$app}";
      export FX_RC="${FX_RC:-${FX_ETC}/fx.rc}";

      export FX_LIB="${FX_LIB:-$XDG_FX_LIB/$app}";
      export FX_INC="${FX_INC:-$FX_LIB/inc}";
      export FX_APP="${FX_LIB}/pkgs/fx"; #location of existing "apps"

      export FX_PROFILE=${FX_PROFILE:-$(canonical_profile)}; #allow a prev set
    fi
  }


  ensure_fx_ready() {
    trace "[DIR] checking application directories...";
    local this var;

    for var in "${fx_var_list[@]}"; do

      this=$(deref_var "$var") #bash 3.2
       
      # Skip empty values
      [ -z "${this}" ] && {
        error "$var is unset or empty!" >&2;
        return 1;
      }

      # Check if it's a directory, or try to create it
      #'^FX_INIT_|^FX_RC|^FX_APP'
      case "$var" in
        (FX_RC|FX_APP_NAME) continue ;;  # skip these vars
      esac

      
      if [ -d "$this" ]; then
        trace "[DIR] $var → $this exists"
      else
        trace "[DIR] $var → $this does not exist, attempting to create..."
        mkdir -p "$this" || {
          err="Failed to create $this for $var" >&2
          return 1;
        }
        okay "Created $this for $var"
      fi
    done #end for
    return 0;
  }





  _boot_session() {
    # Attempt to load the RC file first to get existing settings.
    if load_this_rc_file; then
      info "[RC] FX values loaded from fx.rc";
    fi

    # If core XDG variables are missing, initialize them.
    if [[ -z "$XDG_FX_HOME" || -z "$XDG_FX_LOCAL" ]]; then
      trace "XDG environment not found, initializing..."
      init_xdg;
    fi

    # If the core FX_RC variable is still not set, it means this is likely
    # a first run or a broken environment, so we initialize the defaults.
    if [ -z "$FX_RC" ]; then
      trace "FX environment not found, initializing defaults..."
      init_fx;
    fi
  }



#-------------------------------------------------------------------------------
# FX API
#-------------------------------------------------------------------------------


  fx_get_rc_file(){
    local rc;
    think "Getting this fx rc file...";
    this_context_fx;
    rc="${FX_ETC}/fx.rc"; # Directly use the intended path
    echo "$rc";
    return 0;
  }


  fx_has_link(){
    local rc ret=1;
    fx_link_cmd "has"; ret=$?; ret=$?;
    [ $ret -eq 0 ] && { okay "FX link ound."; return 0; } || { warn "FX link not found."; return 1; }

    return $ret;
  }


  fx_del_link(){
    local rc ret=1;
    fx_link_cmd "del"; ret=$?;
    [ $ret -eq 0 ] && { info "FX rc link removed"; } || { warn "FX rc already unlinked"; }
    return $ret;
  }


  fx_set_link(){
    local rc ret=1;
    fx_link_cmd "add"; ret=$?;
    [ $ret -eq 0 ] && { info "FX link added to profile"; } || { warn "Fx could not link to profile"; }
    return $ret;
  }

  fx_link_cmd(){
    local call="$1" rc=${FX_RC:-=$(fx_get_rc_file)} ret=1;
    case $call in
      (has) cmd='has_profile_link' ;;
      (add) cmd='set_profile_link' ;;
      (del) cmd='rem_profile_bak' ;;
      (*)
        return 1;
      ;;
    esac
    if [ -n "$cmd" ] && function_exists "$cmd"; then
      "$cmd" "$rc";  
      ret=$?;
    fi
    return $ret;
  }


  fx_print_embed(){
    # This function can now call the standard template function directly
    _get_rc_template
  }


#-------------------------------------------------------------------------------
# Troubleshooting
#-------------------------------------------------------------------------------

  do_vars(){
    trace "Dumping debug vars";
    local call="$1" arg="$2" cmd='' ret;
    case $call in
      (xdg)    env | grep '^XDG_FX_';;
      (fx)     env | grep '^FX_' | grep -v '^FX_INIT_' ;;
      (init)   env | grep '^FX_INIT';;
      (*)
        if [ ! -z "$call" ]; then
          err="Invalid prefix => $call";
          return 1;
        fi
      ;;
    esac
    return 0;
  }


  fx_dev_rcfile(){
    this_context_fx;
    dump_this_rc_file;
  }

# @lbl fx clean

  fx_dev_cleanup(){
    think "Doing Dev cleanup...";
    local ret res rcfile;
    rcfile=$(fx_get_rc_file); ret=$?;
    del_this_rc_file; ret=$?;
    fx_del_link;
    # optional remove fxi aliases
  }

  # @lbl fx clean
  # Cleans up all installed packages and manifest
  fx_dev_clean_packages() {
    require_dev || { error "This function requires dev mode."; return 1; }
    think "Cleaning up all installed packages and manifest..."
    if [ -d "$FX_LIB" ]; then
      rm -rf "$FX_LIB" || { error "Failed to remove $FX_LIB"; return 1; }
      okay "Removed $FX_LIB"
    else
      warn "$FX_LIB does not exist, skipping removal."
    fi

    if [ -f "$FX_ETC/manifest.log" ]; then
      rm -f "$FX_ETC/manifest.log" || { error "Failed to remove manifest.log"; return 1; }
      okay "Removed $FX_ETC/manifest.log"
    else
      warn "Manifest file does not exist, skipping removal."
    fi
    okay "Package cleanup complete."
    return 0
  }


# @lbl fx api

  fx_self_promote(){
    info "Promoting devfx to fx..."
    local fx_bin_path="$FX_BIN/fx"
    cp "$SELF_PATH" "$fx_bin_path" || { error "Failed to copy devfx to $fx_bin_path"; return 1; }
    chmod +x "$fx_bin_path" || { error "Failed to make $fx_bin_path executable"; return 1; }
    okay "devfx successfully promoted to fx at $fx_bin_path"
    return 0
  }


#-------------------------------------------------------------------------------
# Setup
#-------------------------------------------------------------------------------
  
# @lbl install

  fx_install(){
    local ret=1;
    think "Setup starting....."

    this_context_fx;
    init_fx;
    fx_this_check;

    if ensure_fx_ready; then
      okay "System has valid paths.";
      fx_unbox_system;
    else
      error "System paths are invalid.";
    fi
    #needs return value
  }

  do_setup(){
    trace "Setting up FX..."
    setup;
  }

  fx_unbox_system(){
    info "Installing BashFX system..."
    local pkgman='';
    
    # Step 1: Deploy all packages and create the manifest using pkgfx
    # This step will be handled by pkgfx's install command, which will iterate through packages
    # and add them to the manifest, then link them.
    # For now, we'll assume pkgfx handles the deployment of all core packages.
    # A future task will define how pkgfx discovers and installs these.
    # For the current setup, we'll simulate this by calling pkgfx install on known core packages.
    
    # Example: Install a dummy package to demonstrate pkgfx integration
    # This will be replaced by a proper package discovery and installation mechanism
    # "$FX_BIN/pkgfx" install "/path/to/some/core/package.sh" || { error "Core package installation failed."; return 1; }

    # Step 2: Verify the integrity of all deployed packages using pkgfx
    pkgman="$FX_BIN/pkgfx" ;

    if [ -x "$FX_BIN/pkgfx" ]; then
      "$FX_BIN/pkgfx" verify || { error "Package integrity verification failed."; return 1; }
    else
      warn "pkgfx not found or not executable, skipping package verification."
    fi
    
    # Step 3: Create and link the rc file
    local rc_file profile_file link_content
    rc_file=$(fx_get_rc_file)
    profile_file=${FX_PROFILE:-$(canonical_profile)}

    # Create the rc file using a robust here-doc template.
    _get_rc_template > "$rc_file" || { error "Failed to save rc file."; return 1; }
    okay "Created rc file at $rc_file"

    # Add the source link to the user's profile if it doesn't exist.
    link_content=$(_get_link_template)
    if ! grep -qF -- "$link_content" "$profile_file"; then
      info "Adding BashFX source to profile: $profile_file"
      echo -e "\n$link_content" >> "$profile_file"
    fi
    
    # Step 4: Promote devfx to fx
    fx_self_promote || { error "Failed to promote devfx to fx."; return 1; }
    
    # Step 5: Clean up the temporary setup environment
    info "Cleaning up temporary setup environment..."
    # Corrected path from 'setup.dev' to 'launch.dev'
    "$FXI_ROOT_DIR/launch.dev" reset || warn "Failed to clean up temporary setup environment."
    
    okay "BashFX installation complete! Please reload your shell (e.g., 'source ~/.bashrc' or open a new terminal) to activate the 'fx' command."
  }




#-------------------------------------------------------------------------------
# Feature Drivers
#-------------------------------------------------------------------------------

  fx_dispatch_driver() {
    local feature_num="$1"
    shift # Remove the feature number from the arguments list
    local driver_func="fx_f$(printf "%03d" "$feature_num")_driver"

    # Source the specific test driver file if it exists
    local test_driver_file="$(dirname "${BASH_SOURCE[0]}")/../tests/test-pkgfx.sh" # Specific for FEATURE-007
    if [ -f "$test_driver_file" ]; then
      source "$test_driver_file"
    fi

    if function_exists "$driver_func"; then
      info "Executing driver for FEATURE-$feature_num..."
      "$driver_func" "$@" # Pass remaining arguments to the driver
    else
      error "Driver function '$driver_func' not found for FEATURE-$feature_num."
      return 1
    fi
  }

  # @driver F003
  fx_f003_driver() {
    local ret=0
    info "DRIVER: Testing FEATURE-003 (Safe Package Deployment)"
    
    # This is a simple "happy path" test.
    # It relies on the setup having been run correctly.
    think "Verifying that the manifest file exists and is not empty..."
    [ -s "$FX_ETC/manifest.log" ] || { error "Manifest file is missing or empty."; return 1; }
    okay "Manifest file exists."

    think "Verifying a known package (semver) is in the manifest..."
    grep -q "semver" "$FX_ETC/manifest.log" || { error "semver package not found in manifest."; ret=1; }
    
    if [ $ret -eq 0 ]; then
      okay "semver package found in manifest."
      okay "DRIVER F003: PASSED"
    else
      error "DRIVER F003: FAILED"
    fi
    return $ret
  }

  # @driver F004
  fx_f004_driver() {
    info "DRIVER: Testing FEATURE-004 (Package Integrity & Linking)"
    
    think "Running master integrity check..."
    # The function returns 0 on success
    fx_integrity_verify_all
    local ret=$?

    if [ $ret -eq 0 ]; then
      okay "DRIVER F004: PASSED"
    else
      error "DRIVER F004: FAILED"
    fi
    return $ret
  }

  # @driver F007
  fx_f007_driver() {
    info "DRIVER: Testing FEATURE-007 (pkgfx Package Manager)"
    local ret=0
    local test_pkg_id="fx.testpkg"
    local devfx_dir
    devfx_dir="$(dirname "${BASH_SOURCE[0]}")"
    local pkgfx_cmd="${devfx_dir}/pkgfx"

    # --- Environment Staging ---
    think "Setting up a clean test environment..."
    init_fx # Ensure temporary FX_* destination vars are set
    ensure_fx_ready || { error "Failed to create temporary FX directories."; return 1; }

    # Explicitly set the SOURCE directories for the test run
    export FXI_ROOT_DIR
    FXI_ROOT_DIR="$(cd "${devfx_dir}/.." && pwd)"
    export FXI_PKG_DIR="${FXI_ROOT_DIR}/pkgs"
    export FXI_INC_DIR="${FXI_PKG_DIR}/inc"
    
    # --- Pre-flight Check ---
    think "Verifying test environment variables..."
    trace "pkgfx command: ${pkgfx_cmd}"
    trace "FXI_ROOT_DIR: ${FXI_ROOT_DIR}"
    trace "FXI_PKG_DIR:  ${FXI_PKG_DIR}"
    trace "FXI_INC_DIR:  ${FXI_INC_DIR}"
    trace "FX_LIB:       ${FX_LIB}"
    trace "FX_ETC:       ${FX_ETC}"
    trace "FX_BIN:       ${FX_BIN}"
    
    # --- Test Execution ---
    # 1. Install testpkg
    think "STEP 1: Installing test package ('$test_pkg_id')..."
    "$pkgfx_cmd" install "$test_pkg_id"
    if [ $? -ne 0 ]; then
      error "STEP 1 FAILED: Install command failed."
      ret=1
    else
      okay "STEP 1 PASSED: Install command succeeded."
    fi

    # 2. List installed packages and verify testpkg is present
    think "STEP 2: Verifying test package is listed as installed..."
    if "$pkgfx_cmd" list --installed | grep -q "$test_pkg_id"; then
      okay "STEP 2 PASSED: Test package found in --installed list."
    else
      error "STEP 2 FAILED: Test package not found in --installed list."
      ret=1
    fi

    # 3. Verify package integrity
    think "STEP 3: Verifying package integrity..."
    if "$pkgfx_cmd" verify; then
      okay "STEP 3 PASSED: Integrity check successful."
    else
      error "STEP 3 FAILED: Integrity check reported an error."
      ret=1
    fi

    # 4. Uninstall testpkg
    think "STEP 4: Uninstalling test package ('$test_pkg_id')..."
    if "$pkgfx_cmd" uninstall "$test_pkg_id"; then
      okay "STEP 4 PASSED: Uninstall command succeeded."
    else
      error "STEP 4 FAILED: Uninstall command failed."
      ret=1
    fi

    # 5. List installed packages and verify testpkg is gone
    think "STEP 5: Verifying test package is no longer listed..."
    if ! "$pkgfx_cmd" list --installed | grep -q "$test_pkg_id"; then
      okay "STEP 5 PASSED: Test package successfully removed from --installed list."
    else
      error "STEP 5 FAILED: Test package still found in --installed list after uninstall."
      ret=1
    fi

    # --- Result ---
    if [ $ret -eq 0 ]; then
      okay "DRIVER F007: ALL STEPS PASSED"
    else
      error "DRIVER F007: ONE OR MORE STEPS FAILED"
    fi

    # --- Cleanup ---
    think "Cleaning up test artifacts..."
    fx_dev_clean_packages >/dev/null 2>&1
    okay "Cleanup complete."

    return $ret
  }




#-------------------------------------------------------------------------------
# System Funcs
#-------------------------------------------------------------------------------
  
  stat_check(){
    local str prof;
    prof=${FX_PROFILE:-$(standard_profile)};ret=$?;
    str+="\t--> Input: ${white2}$1 $2 $3 $4 $5 $6 ${x}\n\n";
    str+="\t FX_RC: $FX_RC \n\n";
    str+="\t FX_PROFILE: $prof \n\n";
    str+="\t$(__flag "$opt_flags" "stats [-f]")\n";
    str+="\t$(__flag "$opt_debug" "debug [-d]")  \t$(__flag $opt_trace "trace [-t]")\n";
    str+="\t$(__flag "$opt_quiet" "quiet [-q]")  \t$(__flag $opt_yes   "yes   [-y]")\n";
    str+="\t$(__flag "$opt_silly" "silly [-V]")  \t$(__flag $opt_dev   "dev   [-D]")\n";  
    quiet_off; #always print flags if requested even if quiet is on
    __boltbox "$str";
  }

# @lbl dispatch

  # Define command mappings for the 'do_inspect' function.
  # This decouples inspection from the dispatch implementation.
  #_dispatch_cmds=( "prof" "docs" "has_link" "link" "unlink" "rc" "init" "vars" "insp" "!" "clean" "clean-pkgs" "stat" "setup" "driver" "help" "?" "noop" )
  #_dispatch_funcs=( "dev_dump_profile" "fx_print_embed" "fx_has_link" "fx_set_link" "fx_del_link" "fx_dev_rcfile" "do_init" "do_vars" "do_inspect" "do_inspect" "fx_dev_cleanup" "fx_dev_clean_packages" "stat_check" "do_setup" "fx_dispatch_driver" "usage" "usage" "noop" )

  # do_inspect() moved to library as a general function

  dispatch(){
    local call="$1" arg="$2"  cmd='' ret;

    case $call in
      (prof)        cmd='dev_dump_profile';; # Note: dev_dump_profile is not defined in this script
      (docs)        cmd='fx_print_embed';;
      (has_link)    cmd='fx_has_link';;
      (link)        cmd='fx_set_link';;
      (unlink)      cmd='fx_del_link';;
      (rc*)         cmd='fx_dev_rcfile';;
      (vars)        cmd='do_vars';;
      (insp*|!)     cmd='do_inspect';;
      (clean)       cmd='fx_dev_cleanup';;
      (clean-pkgs)  cmd='fx_dev_clean_packages';;
      (stat)        cmd='stat_check';;
      (install)     cmd='fx_install';;
      (driver)      cmd='fx_dispatch_driver';;
      (help|?)      cmd="usage";;
      (noop)        cmd="noop";;
    esac

    if [ -n "$cmd" ] && function_exists "$cmd"; then
      shift # remove the command so we can pass the rest
      "$cmd" "$@";   # Pass all extra arguments if cmd is defined
      ret=$?;
    else
      __errbox "Dispatch error, could not find function ($cmd) for command ($call)";
    fi
    [ -n "$err" ] && fatal "$err";
    echo -ne "\n\n";

    return $ret;
  }


  main(){
    local str ret=1;

    #using knife source is determined top of file
    str=$($_knife logo "$SELF_PATH" 3 12); ret=$?;
    info "$str";

    [ $opt_flags -eq 0 ] && { stat_check "${orig_args[@]}"; } # show status printout

    require_dev && str="\t${red2}${boto} Dev mode enabled ${boto}${x}" || str="\n\t\t${grey}${bowtie} User Mode ${x}";
    stderr "$str\n";
    _boot_session
    dispatch "$@"; ret=$?

    [ -n "$err" ] && fatal "$err"
    return $ret
  }



#-------------------------------------------------------------------------------


  if [ "$0" = "-bash" ]; then
    :
  else


    orig_args=("${@}")
    options "${orig_args[@]}";


    # Filter out flags to get positional arguments for main().
    args=()
    for arg in "${orig_args[@]}"; do
      [[ "$arg" == -* ]] && continue
      args+=("$arg")
    done

    main "${args[@]}";

  fi
