#!/usr/bin/env bash

# note: FXI_ prefix implies setup variables formerly known as FX_INIT_*
# note: sourcing include.sh automatically includes stderr.sh


#===============================================================================

#-------------------------------------------------------------------------------

# source "./setup.conf"; <--configurations would go here
if [ -n "$NO_COLOR" ]; then
  _red=
  _red2=
  _blue=
  _gold=
  _green=
  _purple=
  _purple2=
  _grey=
  _reset=
else
  _red=$'\x1B[31m';
  _red2=$'\x1B[38;5;197m';
  _blue=$'\x1B[38;5;39m';
  _gold=$'\x1B[38;5;220m';
  _grey=$'\x1B[90m';
  _green=$'\x1B[32m';

  _purple=$'\x1B[38;5;213m';
  _purple2=$'\x1B[38;5;141m';
  _reset=$'\x1B[0m';
fi
#-------------------------------------------------------------------------------

__exists(){ type "$1" >/dev/null 2>&1; }

# Finds the user's canonical shell profile file (.profile or .bash_profile).
# It resolves symlinks to find the true file path.
fxi_canonical_profile() {
  local BASH_PROFILE

  # Prefer .profile if it exists (as any file type, including symlink),
  # otherwise fall back to .bash_profile.
  if [ -e "$HOME/.profile" ]; then
    BASH_PROFILE="$HOME/.profile"
  else
    BASH_PROFILE="$HOME/.bash_profile"
  fi

  # Resolve symlinks to find the actual file path.
  if command -v realpath >/dev/null 2>&1; then
    # Use the native, reliable tool if it exists.
    BASH_PROFILE=$(realpath "$BASH_PROFILE")
  elif [ -L "$BASH_PROFILE" ]; then
    # Use a pure-bash fallback if realpath is not available.
    # This loop handles nested symlinks (link to a link).
    local current_path="$BASH_PROFILE"
    local i=0
    while [ -L "$current_path" ] && [ "$i" -lt 10 ]; do
      local target
      target=$(readlink "$current_path")
      # If the link is relative, resolve it against its directory
      [[ "$target" != /* ]] && target="$(dirname "$current_path")/$target"
      current_path="$target"
      ((i++))
    done
    BASH_PROFILE="$current_path"
  fi

  echo "$BASH_PROFILE"
}

#-------------------------------------------------------------------------------


# Generates the .fxlaunchrc file with dynamic paths and helper aliases.
# This file establishes the initial development environment.
# @param $1 - The absolute path where the RC file should be created.
fxi_launchrc(){
  local src=$1;
  [ -z $src ] && return 1;
cat > "$src" << EOF
#!/usr/bin/env bash

  export FXI_LAUNCH_RC="$src";
  export FXI_ROOT_DIR="$FXI_ROOT_DIR";
  export FXI_BIN_DIR="\$FXI_ROOT_DIR/bin";
  export FXI_PKG_DIR="\$FXI_ROOT_DIR/pkgs";
  export FXI_APP_DIR="\$FXI_ROOT_DIR/pkgs/fx";
  export FXI_INC_DIR="\$FXI_ROOT_DIR/pkgs/inc";

  if [[ ":\$PATH:" != *":\$FXI_BIN_DIR:\$FXI_INC_DIR:"* ]]; then
    export PATH="\$PATH:\$FXI_BIN_DIR:\$FXI_INC_DIR"
    printf "Launch added project bin and pkg to path...\n";
  fi

  if [[ ":\$PATH:" != *":\$FXI_APP_DIR/knife:"* ]]; then
    export PATH="\$PATH:\$FXI_APP_DIR/knife"
    printf "Launch added knife utility to path... \n";
  fi

  # fxproto aliases
  alias fxp="devfx";
  alias fxinstall="fxp install";
  alias fxpi="fxinstall";
  alias fxph="fxp help";

  # launcher aliases
  alias fxlaunch="source $FXI_ROOT_DIR/launch.dev";
  alias fxlrm="fxlaunch reset";
  alias fxlrc="fxlaunch dumprcs";
  alias fxnxt="fxlaunch check";
  alias fxlh="fxlaunch help"

  alias fxknife="knife.sh --portable";


EOF

  [ -f "$src" ] && return 0;
  return 1;
}
#-------------------------------------------------------------------------------


# Dumps the content of the existing .fxlaunchrc file to stdout.
fxi_launchrc_dump(){
  if [ -f "$FXI_LAUNCH_RC" ]; then
    cat "$FXI_LAUNCH_RC";
    return 0;
  else
    printf "${_red}Error loading generated RC file (%s)\n${_reset}" "$FXI_LAUNCH_RC";
  fi
}

#-------------------------------------------------------------------------------

# Checks if the user's profile file contains the source line for .fxlaunchrc.
fxi_has_link(){
  local _line="source \"$FXI_LAUNCH_RC\";";
  grep -qF "$_line" "$PROFILE";
}

#-------------------------------------------------------------------------------


# Checks if the setup is complete (i.e., the RC file exists and is linked).
fxi_ready(){
  if fxi_has_link; then
    [ -f "$FXI_LAUNCH_RC" ] && return 0;  
  fi
  return 1;
}

#-------------------------------------------------------------------------------

# Initializes the development environment by creating the .fxlaunchrc file
# and linking it to the user's profile.
fxi_launch(){

  local res ret _line; 

  # Use a pre-defined FXI_ROOT_DIR for testing, otherwise calculate it.
  export FXI_ROOT_DIR="${FXI_ROOT_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && echo "$PWD")}"
  FXI_LAUNCH_RC="${FXI_ROOT_DIR}/.fxlaunchrc";

  fxi_launchrc "$FXI_LAUNCH_RC"; ret=$?;
  
  if [ $ret -eq 0 ]; then
    _line="source \"$FXI_LAUNCH_RC\";"
    grep -qF "$_line" "$PROFILE" || echo "$_line" >> "$PROFILE";

    #load vars defined in .fxlaunchrc
    if [ -f "$FXI_LAUNCH_RC" ]; then
      FXI_STAT='start';source "$FXI_LAUNCH_RC";
      printf "${_purple2}Launcher Environment Initialized...${_reset}\n";
      fxi_next
      return 0;
    else
      printf "${_red}Error loading generated RC file (%s)\n${_reset}" "$FXI_LAUNCH_RC";
    fi
  else
    printf "${_red}Error creating RC file (%s)\n${_reset}" "$FXI_LAUNCH_RC";
  fi

  return 1;
}

#-------------------------------------------------------------------------------

# Removes the development environment setup by deleting the .fxlaunchrc file,
# removing the source line from the profile, and unsetting env vars/aliases.
fxi_reset(){
  local _line _profile_tmp;
  printf "${_red}Removing Launcher Environment ...${_reset}\n";

  # Make the uninstall process stateless by determining paths independently.
  export FXI_ROOT_DIR="${FXI_ROOT_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")" && echo "$PWD")}"
  FXI_LAUNCH_RC="${FXI_ROOT_DIR}/.fxlaunchrc"

  # Use grep -vF for safer fixed-string matching to remove the source line.
  _line="source \"$FXI_LAUNCH_RC\";"
  _profile_tmp="${PROFILE}.tmp.$$"
  if grep -vF -- "$_line" "$PROFILE" > "$_profile_tmp" && mv "$_profile_tmp" "$PROFILE"; then
    : # Successfully removed line
  else
    printf "${_red}Warning: could not modify profile file at %s${_reset}\n" "$PROFILE"
    rm -f "$_profile_tmp" # Clean up temp file on failure
  fi

  # Remove the RC file if it exists.
  rm -f "$FXI_LAUNCH_RC"

  # Use compgen to concisely unset all aliases and functions starting with 'fx'.
  # This is more robust and readable than parsing output with awk.
  for alias_name in $(compgen -A alias fx); do unalias "$alias_name" 2>/dev/null; done
  for func_name in $(compgen -A function fxi_); do unset -f "$func_name"; done

  # Unset all environment variables.
  for var in $(compgen -v FXI_); do unset "$var"; done

  # Unset the color variables used by this script.
  unset _red _red2 _blue _gold _grey _green _purple _purple2 _reset

  printf "${_green}Uninstall complete.${_reset}\n";
}


#-------------------------------------------------------------------------------

# Displays status and contextual next steps to the user, guiding them on
# how to proceed with setup or use the available aliases.
fxi_next(){
  if fxi_ready; then
    printf "\nBashFX (fx) is ready for installation!\n";
    printf "Use [${_blue}fxinstall${_reset}] to complete. \n\n";
    printf "${_grey}Additional Command aliases: \n\n${_reset}";
    printf "${_green}fxlaunch next${_reset}  : check the next step. \n";
    printf "${_green}fxlaunch reset${_reset} : remove/uninstall BashFX setup. \n";
    printf "${_green}fxlaunch rc${_reset}    : dump setup rc file. \n";
    printf "${_green}fxlaunch help${_reset}  : see more commands. \n";

    printf "${_green}fxp${_reset}            : advanced/dev utils. \n";
    printf "${_green}fxknife${_reset}        : portable knife. \n";

  elif [ -n "$FX_RC" ] && [ -f "$FX_RC" ]; then
    printf "${_green}BASHFX looks installed.${_reset}\n";
  else 
    printf "\nRun '${_blue}source launch.dev launch${_reset}' in the project root to setup the launcher.\n\n${_grey}Other commands: 'reset check dumprc'${_reset}";
  fi
}


fxi_cmds(){
cat << EOF

    Quick and dirty dev launch help.

    Launch:

    fxlaunch          (main command)
    fxlaunch reset    (fxlrm)
    fxlaunch check    (fxinext)
    fxlaunch dumprc   (fxirc) 

    Install:

    fxp install       (fxpi)
    fxp help          (fxph)
    
    Dev Utils:

    fxknife           (fxpk)

EOF
}



#-------------------------------------------------------------------------------

# Main entry point and command dispatcher for the script.
# It parses arguments and calls the appropriate setup/utility function.
fxi_main(){
  local arg FXI_STAT;

  PROFILE=$(fxi_canonical_profile);

  if [ ! -f "$PROFILE" ]; then
    printf "${_red}Error! canonical bash profile missing (path: %s)\n${_reset}" "$PROFILE";
    return 1;
  fi


  if [ "$#" -eq 0 ]; then
    fxi_next;
    return 0;
  fi

  if [ -f "$FXI_LAUNCH_RC" ]; then
    :
    # FXI_STAT='reload'; source "$FXI_LAUNCH_RC";
  fi

  arg="${1:-}" # Use first argument or empty string if not set

  case "$arg" in
    (res|reset)  fxi_reset; return 0;;
    (rc)         fxi_launchrc; return 0;;
    (cmds|help)  fxi_cmds; return 0;;
    (check|next) fxi_next; return 0;;
    (link)       fxi_has_link; return 0;;
    (dumprc)     fxi_launchrc_dump; return 0;;
    (launch)     fxi_launch; return 0;;
    ("")        # Already handled by the check for $# -eq 0
                return 0;;
    (*)         printf "${_red}Unknown command (%s)${_reset}\n" "$arg"; return 1;;
  esac
}



# If FXI_TEST_MODE is not set, run the script's main logic and cleanup.
# This allows a test harness to source this script to load the functions
# without executing them immediately.
if [ -z "$FXI_TEST_MODE" ]; then
  fxi_main "$@"

  # Automatic Cleanup:
  # This runs after fxi_main completes to remove the launcher's own functions
  # from the user's shell, preventing pollution. This is the correct pattern
  # for sourced scripts, as 'trap EXIT' would not work as expected.
  for func_name in $(compgen -A function fxi_); do unset -f "$func_name"; done
  unset -f "__exists";

  unset _red _red2 _blue _gold _grey _green _purple _purple2 _reset;
fi
